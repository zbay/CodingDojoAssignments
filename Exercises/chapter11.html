<html>
    <head>
        <title>Chapter 11: Trees</title>
        <script>
            function BTNode(value){
                this.value = value;
                this.left = null;
                this.right = null;
            }
            function BST(){
                this.root = null;

                this.add = function(val){
                    if(!this.root){
                        this.root = new BTNode(val);
                        console.log("Added: " + val);
                        return this;
                    }
                    else{
                        return rAdd(this.root);
                    }

                    function rAdd(current){
                        if(!current){
                            return;
                        }
                        if(!current.left && val < current.value){
                            console.log("Added: " + val);
                            current.left = new BTNode(val);
                            return this;
                        }
                        else if(!current.right && val >= current.value){
                            console.log("Added: " + val);
                            current.right = new BTNode(val);
                            return this;
                        }
                        else if(current.value < val){
                            rAdd(current.right);
                        }
                        else{ // current.value >= val
                            rAdd(current.left);
                        }
                    }
                }

                    this.isEmpty = function(){
                        return this.root === null;
                    }

                    this.size = function(){
                        if(this.isEmpty()){
                            return 0;
                        }
                        return rSize(this.root);

                        function rSize(node){
                            if(!node.left && !node.right){
                                return 1;
                            }
                            else if(!node.left){
                                return 1 + rSize(node.right);
                            }
                            else if(!node.right){
                                return 1 + rSize(node.left);
                            }
                            else{
                                return 1 + rSize(node.left) + rSize(node.right);
                            }
                        }
                    }

                    this.display = function(){
                        rShow(this.root);
                        function rShow(current){
                            if(!current){
                                console.log("The BST is empty!");
                                return;
                            }
                            console.log(current.value);
                            rShow(current.left);
                            rShow(current.right);
                        }
                    }

                    this.max = function(){
                        let current = this.root;
                        while(current.right){
                            current = current.right;
                        }
                        return current.value;
                    }

                    this.min = function(){
                        let current = this.root;
                        while(current.left){
                            current = current.left;
                        }
                        return current.value;
                    }

                    this.contains = function(val){
                        return rContains(this.root);

                        function rContains(current){
                            if(current.value === val){
                                return true;
                            }
                            else if(current.left && current.value > val){
                                return rContains(current.left);
                            }
                            else if(current.right && current.value <= val){
                                return rContains(current.right);
                            }
                            else{
                                return false;
                            }
                        }
                    }

                    this.height = function(){
                        if(!this.root){
                            return 0;
                        }
                        return rHeight(this.root);

                        function rHeight(current){
                            if(!current){
                                return 0;
                            }
                            let leftHeight = rHeight(current.left);
                            let rightHeight = rHeight(current.right);
                            if(!current.left && !current.right){
                                return 1;
                            }
                            else if(current.right && current.left){
                                return(leftHeight >= rightHeight ? 1 + leftHeight : 1 + rightHeight);
                            }
                            else if(current.right){
                                return 1 + rightHeight;
                            }
                            else{ // current.left
                                return 1 + leftHeight;
                            }
                        }
                    }

                    this.isBalanced = function(){
                        let heightFunc = this.height;
                        if(!this.root){
                            return true;
                        }
                        return rBalanced(this.root);

                        function rBalanced(cur){
                            if(!cur){
                                return true;
                            }
                            return (Math.abs(heightFunc(cur.left) - heightFunc(cur.right)) < 2) && rBalanced(cur.left) && rBalanced(cur.right);
                        }
                    }

                    this.preOrder = function(){
                        preHelper(this.root);

                        function preHelper(node){
                            if(!node){
                                return;
                            }
                            console.log(node.value);
                            preHelper(node.left);
                            preHelper(node.right);
                        }
                    }
                    this.postOrder = function(){
                        postHelper(this.root);

                        function postHelper(node){
                            if(!node){
                                return;
                            }
                            postHelper(node.left);
                            postHelper(node.right);
                            console.log(node.value);
                        }
                    }

                }
                function arrayToBST(arr){
                    let newBST = new BST();
                    while(arr.length > 0){
                        let mid = Math.floor(arr.length/2);
                        newBST.add(arr.splice(mid, 1));
                        mid = Math.floor(arr.length/2);
                        if(mid > 0){
                            let leftMid = Math.floor(mid/2);
                            newBST.add(arr.splice(leftMid, 1));
                        }
                        mid = Math.floor(arr.length/2);
                        if(mid < arr.length-1){
                            let rightMid = Math.floor(mid+((arr.length-mid)/2));
                            newBST.add(arr.splice(rightMid, 1)); 
                        }
                    }
                    return newBST;
                }

                function closestCommonAncestor(bst, val1, val2){   
                    if(!bst || !bst.root || !bst.root.value || !bst.contains(val1) || !bst.contains(val2)){
                        return false;
                    }
                    let leftBST = new BST();
                    let rightBST = new BST();
                    leftBST.root = bst.root.left;
                    rightBST.root = bst.root.right;
                    if(leftBST.contains(val1) && leftBST.contains(val2)){
                        return closestCommonAncestor(leftBST, val1, val2);
                    }
                    else if(rightBST.contains(val1) && rightBST.contains(val2)){
                        return closestCommonAncestor(rightBST, val1, val2);
                    }
                    else{
                        return bst.root.value;
                    }
                }
            
            //resume pg. 119: bst to array


            let bst = new BST();
            //console.log(bst.isEmpty());
           /* bst.add(20);
            bst.add(10);
            bst.add(30);
            bst.add(15);
            bst.add(5);
            //console.log(bst.max());
            //console.log(bst.min());
            //console.log(bst.isEmpty());
            bst.display();
            console.log(bst.size());
            console.log(bst.height()); // 3
            console.log(bst.isBalanced()); // true
            bst.add(3);
            console.log(bst.isBalanced()); // false
            console.log(bst.height());
            bst.add(1);
            console.log(bst.height());
            console.log(bst.isBalanced());*/

            bst.add(10);
            bst.add(3);
            bst.add(20);
            bst.add(1);
            bst.add(5);
            bst.add(15);
            bst.add(30);
            console.log(closestCommonAncestor(bst, 7, 12)); // false
            console.log(closestCommonAncestor(bst, 1, 5)); // 3
            console.log(closestCommonAncestor(bst, 15, 30)); // 20
            console.log(closestCommonAncestor(bst, 20, 10)); // 10

        </script>
    </head>
    <body></body>
</html> 